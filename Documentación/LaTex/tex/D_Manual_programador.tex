\apendice{Documentación técnica de programación}

\section{Introducción}

\section{Estructura de directorios}
\noindent Para comenzar, mostraremos los archivos existentes en la raíz del proyecto. Cabe mencionar que la estructura de la versión anterior del visor ha sido modificada ya que no seguía una estructura correcta para su despliegue en un servidor. Por ello, la aplicación en sí se encuentra en la raíz.

\begin{itemize}
	\item \textbf{.gitignore} Posee los diferentes elementos que el sistema \textit{GIT} debe evitar revisar.
	\item \textbf{activate\_this.py} Archivo que deberá ser movido por el operador del servidor a la carpeta \texttt{mi\_venv/bin/} con el fin de que Apache adquiera las dependencias de instaladas en el entorno virtual.
	\item \textbf{config.py} Archivo de configuración predeterminada. Estos parámetros se verán sobrescritos por los añadidos en \texttt{instance/config.py}.
	\item \textbf{host\_config.txt} Configuración de Apache para la máquina proporcionada como servidor.
	\item \textbf{install\_run.bat} \textit{Script} para Windows que genera un entorno virtual, lo registra, instala las dependencias Python, y lanza el servidor.
	\item \textbf{install\_run.sh} El mismo \textit{script}, pero para Linux.
	\item \textbf{jsconfig.json} Archivo de configuración para \textit{VSCode}.
	\item \textbf{MyApp.wsgi} Archivo que sirve de configuración para que Apache (\textit{mod\_wsgi}) sepa que tiene que ejecutar.
	\item \textbf{package.json} Define las dependencias y comandos disponibles llamándolo desde npm (Node).
	\item \textbf{requirements.txt} Requisitos de los módulos para Python.
	\item \textbf{rollup.config.js} Configuración para el \textit{plugin} que empaqueta el código.
	\item \textbf{runserver.py} \textit{Script} que carga el módulo principal para lanzar el servidor.
	\item \textbf{runtime.txt} Fichero que contiene el entorno de ejecución de la aplicación.
	\item \textbf{tyings.json} Configuración IntelliSense de Visual Studio Code.
\end{itemize}

A continuación, mostraremos las diferentes carpetas dentro de la raíz del proyecto, pasando a su posterior despliegue:

\begin{itemize}
	\item Documentación
	\item instance
	\item mi\_venv
	\item MyApp
	\item node modules
	\item Resources
	\item src
	\item typings
\end{itemize}

\noindent Entraremos a partir de ahora en detalle.

\subsection{Documentación}
En ella tendremos el conjunto de documentaciones generadas para el proyecto, cuyas carpetas son:
\begin{itemize}
	\item \textbf{javascript} En ella tenemos la documentación generada para la parte Javascript, esto es, toda la lógica e interfaz del visor.
	\item \textbf{LaTex} Contiene la memoria y anexos del proyecto.
	\item \textbf{python} Posee la documentación generada mediante Sphinx\footnote{\url{http://www.sphinx-doc.org/en/stable/}} para el servidor.
\end{itemize}

\subsection{instance}
Aunque no es un directorio incluido en el repositorio, debemos mencionarlo, puesto que en él incluiremos algunas configuraciones propias de la instancia que estemos desplegando o desarrollando y que no queramos incluir en la versión que subamos al servidor. Algunos archivos de utilidad que meteremos son:
\begin{itemize}
	\item \textbf{config.py} En este archivo incluiremos algunos parámetros de configuración que debemos sobrescribir, como el estado de \texttt{<<DEBUG>>}, o el secreto de aplicación \texttt{<<SECRET\_KEY>>}.
	\item \textbf{users\_to\_import.csv} Es la ruta por defecto para el archivo \textit{CSV} que nos permite importar la lista de usuarios a los que queremos dar permiso.
\end{itemize}

\subsection{mi\_venv}
Entorno virtual en e que se instalarán las dependencias correspondientes para la posterior ejecución de la aplicación.

\subsection{MyApp}
En él está la aplicación en sí misma, casi toda la lógica de negocio y toda la visualización. Dicha carpeta contiene:
\begin{itemize}
	\item \textbf{sql\_scripts} Incluye los \textit{scripts} de utilidad para la base de datos.
	\item \textbf{static} Directorio para cargar elementos estáticos de las páginas.
	\begin{itemize}
		\item \textbf{images} Contiene las imágenes utilizadas en la aplicación.
		\item \textbf{js} \textit{Scripts} que importaremos. Aquí tendremos el código JavaScript una vez transpilado, y por tanto, gran parte de la lógica del visor.
		\item \textbf{uploads} En este directorio terminan los modelos, además de los \textit{PNG} como sus miniaturas.A su vez contiene:
		\begin{itemize}
			\item \textbf{exercises} Incluye los ejercicios realizados por el profesor que servirá de ayuda a la hora de corregir.
		\end{itemize}
	\end{itemize}
	\item \textbf{templates} En él se encuentran las plantillas en formato jinja2\footnote{\url{http://jinja.pocoo.org/}}.
	\item \textbf{translations} En este directorio encontraremos los ficheros plantilla para poder realizar la traducción con Babel.
	\item \textbf{babel.cfg} Configuración con la que Babel busca las etiquetas identificadoras.
	\item \textbf{forms.py} Contiene constructores de los diferentes formularios.
	\item \textbf{\_\_init\_\_.py} Constructor del módulo.
	\item \textbf{messages.pot} Binario con las traducciones de Babel ya realizadas
	\item \textbf{read\_write\_ply.py} Archivo que contiene el código necesario para posibilitar la lectura de archivos \textit{.PLY}.
	\item \textbf{User.py} Clase necesaria para la gestión de usuarios.
	\item \textbf{users.db} Base de datos que alberga la información de los usuarios admitidos.
	\item \textbf{views.py} Contiene los diferentes \textit{endpoints} de nuestro servidor.
\end{itemize}

\subsection{node modules}
Contiene el conjunto de dependencias \textit{Node}.

\subsection{Resources}
Contiene algunos recursos que no sabíamos donde meter, pues no pertenecen estrictamente a ninguna de las partes anteriores. Entre sus elementos se encuentran los archivos <<fuente>> de los diagramas, o los generadores de informes para los archivos \textit{PLY}, que posiblemente integremos en un futuro sobre el servidor.

\subsection{src}
Código fuente de JavaScript sin compilar.

\subsection{typings}
Archivos de configuración para nuestro \textit{IDE} (Visual Studio Code).

\section{Manual del programador}\label{sec:manual-programador}

\subsection{Instalación y configuración de Moodle como API Rest}
Como se mencionó en los aspectos relevantes de la memoria, es necesario configurar \textit{Moodle} para poder utilizarlo como una \textit{API Rest}. A continuación se detalla como configurar la \textit{API}.

En primer lugar debemos tener un usuario con el rol de administrador de la plataforma para poder acceder a la \textit{Administración del sitio} para poder activar los servicios web que por defecto vienen desactivados. Deberemos dirigirnos a \textit{Administración del sitio--Características avanzadas} y habilitar los servicios web. Una vez hecho esto deberemos activar el protocolo \textit{Rest}, que básicamente es el protocolo seguido por una \textit{API Rest}, el cual se accede mediante \textit{Administración del sitio -- Extensiones -- Servicios Web -- Administrar protocolos} y habilitamos dicho protocolo.

A su vez, para que podamos acceder a dichas funcionalidades, además de tener que estar el servicio web y el protocolo activado, lo usuarios deben tener una ficha o \textit{token} el cual los identifique de manera única. Para generar desde nuestra \textit{API} dichos \textit{tokenes} nos dirigiremos a \textit{Administración del sitio -- Extensiones -- Servicios web -- Administrar tokens} y ahí generaremos los tokens para los usuarios. De esta manera, cada usuario tendrá un identificador único para realizar las peticiones correspondientes~\cite{moodle:api-rest-config}.

\subsection{Tratamiento de los roles de los usuarios}
Como se mencionó en los aspectos relevantes de la memoria, inicialmente se tenía una idea de realizar una comprobación de la base de datos para obtener los roles de usuario. Posteriormente se decidió que obtener dichos roles directamente de \textit{UBUVirtual} era más correcto.

Para ellos utilizamos las funciones proporcionadas por \textit{Moodle} para realizar peticiones a nuestra \textit{API Rest} (véase la sección de \textit{Conceptos Teóricos}), que en este caso es UBUVirtual. En dicho listado de funciones (~\cite{moodle:web-service-api-functions}) encontramos la función \textit{core enrol get enrolled users}, la cual nos permitirá conocer los usuarios de la asignatura, así como su rol en la misma y más información variada de cada uno de los participantes. Dicha función nos muestra esta información en forma de diccionario \textit{JSON} desde el que buscaremos al usuario correspondiente para así conocer su rol en la asignatura correspondiente. Dicha información nos es presentada con la estructura definida en la figura~\ref{fig:user-info-JSON}:
\imagen{user-info-JSON}{Estructura de la información proporcionada por la API en formato JSON.}{0.9}

Como se puede apreciar en el campo \textit{roles} nos encontramos con el rol correspondiente del usuario en cuestión, que en este caso es \textit{Profesor} y el id de dicho rol es $3$.

\subsection{Obtención de los modelos}
Ya que la idea inicial era la de obtener los modelos a través de \textit{UBUVirtual} mediante recursos, cabe mencionar como conseguimos obtenerlos aunque la idea no prosperase.

Para ello, recurrimos de nuevo a las funciones \textit{API Rest} siendo esta vez la función \textit{mod resource get resources by courses} la elegida ~\cite{moodle:web-service-api-functions}. Dicha función nos ofrece la información de los recursos presentes en la \textit{API} de UBUVirtual en los cursos correspondientes. En el caso de no seleccionar un curso en concreto, nos devuelve cada uno de los recursos a los que dicho usuario puede acceder. La información resultante tiene la estructura definida en la figura~\ref{fig:JSON-resources}:
\imagen{JSON-resources}{Estructura de la información proporcionada por la API en formato JSON.}{0.9}

De esta manera podemos acceder al nombre de recurso con su correspondiente extensión y comprobar que es del curso correspondiente mediante el campo \textit{course}.

Pero posteriormente, la Universidad de Burgos nos proporcionó un servidor privado, de nombre <<Arquímedes>> en el que podemos desplegar nuestra \textit{API} sin necesitar por ello todo lo mencionado anteriormente acerca de los albergar los modelos como recursos de \textit{UBUVirtual}, ya que podremos albergarlos en nuestro servidor.

\section{Encriptado y desencriptado de los modelos}
Para otorgar seguridad a los modelos, hemos tenido que encriptar los mismos de manera que el modelo que se alberga en el servidor esté modificado de tal manera que alguien ajeno a la \textit{API} que quiera obtener datos o modificar los datos guardados de los modelos sea incapaz.

Con el fin de realizar modificaciones en los modelos 3D para así preservar su seguridad y unicidad, se ha decidido generar una secuencia de números aleatorios con una estructura determinada. De esta manera, conociendo la semilla utilizada para la generación de los números, podremos codificar y decodificar nuestros modelos sin miedo a perder datos importantes de los mismos. Para obtener dichos números aleatorios hemos introducido en el código una función la cual dada un número, nos devuelve otro, con lo cual realizando esta operación un cierto número de veces, obtendremos una secuencia de números <<aleatorios>> (se encuentra entrecomillado porque los valores son aleatorios, pero si se conoce la semilla inicial siempre obtendremos la lista de valores en el mismo orden)\footnote{\url{https://cdsmith.wordpress.com/2011/10/10/build-your-own-simple-random-numbers/}}.

\subsubsection{Obtención de los números aleatorios}\label{sec:numero-aleatorio}
La manera de obtener números aleatorios en el caso de los vértices es la siguiente: \text{$7$ * número aleatorio anterior \% $101$}, mientras que en el caso de las caras obtendremos los valores aleatorios de la siguiente manera: \text{$7$ * número aleatorio anterior \% $11$}. Vemos que la diferencia reside en el valor máximo que puede alcanzar el número aleatorio.

\subsubsection{Para la modificación de los valores de los vértices}
Llegados a este punto tendremos que decidir cómo modificar los valores de los modelos, para lo cual hemos realizado un estudio de los tiempos que tarda el modelo en ser encriptado. La operación a realizar en cada caso será determinada por el tipo de los valores que se vayan a modificar.

Siendo la manera de generar los números aleatorios la mencionada en la sección~\ref{sec:numero-aleatorio} y la manera de modificar los valores de los vértices: \text{valor del vértice * ($2$ * número aleatorio obtenido)}, estaríamos en la encrucijada de elegir la cantidad de operaciones a realizar debido al gran volumen de datos que queremos modificar, por lo tanto hemos obtenido:

\textbf{Para los modelos ASCII:}
\begin{itemize}
	\item Si modificamos todos los vértices que componen al modelo obtenemos un tiempo de: $12.0131$ segundos
	\item Si modificamos solamente los vértices que ocupan posiciones pares del modelo (la mitad de operaciones) obtenemos un tiempo de: $10.2731$ segundos
\end{itemize}

\textbf{Para los modelos Binarios:}
\begin{itemize}
	\item Si modificamos todos los vértices que componen al modelo obtenemos un tiempo de: $2.7190$ segundos
	\item Si modificamos solamente los vértices que ocupan posiciones pares del modelo (la mitad de operaciones) obtenemos un tiempo de: $2.0486$ segundos
\end{itemize}

Una vez conocidos estos datos, decidimos modificar únicamente los valores que ocupan posiciones pares, ya que la encriptación del modelo es suficiente para conservar su seguridad como podemos observar a continuación y el tiempo de codificación es menor:

Teniendo un modelo inicial como el de la figura~\ref{fig:skull-corrected-notencripted}:
\imagen{skull-corrected-notencripted}{Modelo de partida.}{0.9}

Obtendremos un modelo encriptado como el mostrado en la figura~\ref{fig:skull-corrected-encripted}:
\imagen{skull-corrected-encripted}{Modelo de encriptado.}{0.9}

Como se puede apreciar, el modelo encriptado es lo suficientemente difuso como para poder obtener mediciones o datos del mismo en caso de que este fuera robado de la carpeta de almacenamiento de la aplicación. Pero a partir de aquí nos surge el problema relacionado con el redondeo de los decimales, así como de la cantidad de decimales que se devuelven al realizar un \textit{casteo} a otra clase (por ejemplo de \textit{str a float} en \textit{Python}).

Tras realizar las operaciones de codificación del modelo, procedimos a comprobar que los valores obtenidos dividido entre los valores originales nos devolvieran el multiplicando (nuestro número aleatorio~\ref{sec:numero-aleatorio}) y es aquí cuando nos damos cuenta de que no podemos utilizar los valores en coma flotante de los vértices ya que al multiplicar o dividir, los valores de los mismo son corrompidos por los redondeos y el número de decimales. Por ejemplo, para un multiplicando de $0,7$, al dividir el valor obtenido entre el valor inicial obtenemos que el multiplicando es $0.7129$, con lo que podemos concluir que esta no es una manera viable de encriptar los modelos. A continuación mostramos el modelo de la figura~\ref{fig:skull-corrected-notencripted} desencriptado tras modificar sus vértices en la figura~\ref{fig:skull-modified-floats}:
\imagen{skull-modified-floats}{Modelo desencriptado utilizando los valores de los vértices.}{0.9}

\subsubsection{Para la modificación de los valores de las caras}
Tras el resultado nefasto de modificar los valores de los vértices, decidimos que podríamos alterar los valores de las caras formadas por los vértices, las cuales son enteras y no tendremos el problema de los decimales. En este caso, siendo la manera de generar los números aleatorios la mencionada en la sección~\ref{sec:numero-aleatorio} y la manera de modificar los valores de las caras: \text{valor de la cara * (número aleatorio obtenido * $10$) + (número aleatorio obtenido * $100$)} habiendo también realizado un estudio de los tiempos de codificación de los modelos, teniendo en cuanta que el número de caras en el modelo cogido de ejemplo es $248\,999$ mientras que el número de vértices es de $126\,720$:

\textbf{Para los modelos ASCII:}
\begin{itemize}
	\item Si modificamos todos los vértices que componen al modelo obtenemos un tiempo de: $14.1245$ segundos
	\item Si modificamos solamente los vértices que ocupan posiciones múltiplos de cuatro del modelo (la cuarta parte de operaciones) obtenemos un tiempo de: $11.1153$ segundos
\end{itemize}

\textbf{Para los modelos Binarios:}
\begin{itemize}
	\item Si modificamos todos los vértices que componen al modelo obtenemos un tiempo de: $2.9409$ segundos
	\item Si modificamos solamente los vértices que ocupan posiciones múltiplos de cuatro del modelo (la cuarta parte de operaciones) obtenemos un tiempo de: $1.9845$ segundos
\end{itemize}

Una vez conocidos estos datos, decidimos modificar únicamente los valores que ocupan posiciones múltiplos de cuatro. Con esta modificación, la encriptación del modelo es suficiente para conservar su seguridad (el modelo no se llega a mostrar en el navegador ya que no es capaz de dibujarlo) y el tiempo de codificación es menor. De este modo obtenemos tanto una mejor codificación en lo relacionado con la seguridad como de precisión de resultados tras la decodificación. Por lo tanto, concluiremos adjudicando a las \textbf{caras} la encriptación en lugar de a los \textbf{vértices}.

Obtendremos un modelo encriptado como el mostrado en la figura~\ref{fig:skull-corrected-encripted}:
\imagen{skull-corrected-encripted}{Modelo de encriptado.}{0.9}

\subsection{Ejecución de nuestra aplicación en arquimedes}
Hay un script que ejecuta la aplicación. Desde Linux con el comando ssh (usuario y contraseña), en windows con putty y lo mismo. Una vez que se esté ejecutando, accederemos a la aplicación en la dirección url: \url{https://arquimedes.ubu.es/visor3d/}.

\section{Compilación, instalación y ejecución del proyecto}

\section{Pruebas del sistema}
